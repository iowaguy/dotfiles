#+TITLE: Emacs Configuration
#+AUTHOR: Ben Weintraub
#+EMAIL: ben@weintraub.xyz
#+OPTIONS: num:nil
#+PROPERTY: header-args:emacs-lisp :noweb yes :results none

#+begin_src emacs-lisp
  (defun blw/set-macos-vars ()
    (setq blw/open-firefox "open -a Firefox")
    (setq blw/screenshot "screencapture -i %s")

    ;; Bind =alt= to =super=
    (setq ns-alternate-modifier (quote super))

    ;; Bind =command= to =meta=
    (setq ns-command-modifier (quote meta))

    ;; Bind =fn= to =control=
    (setq ns-function-modifier (quote control)))

  (defun blw/set-linux-vars ()
    (setq blw/open-firefox "firefox --newtab --url")
    (setq blw/screenshot "scrot --select %s"))

  (defun blw/set-system-specific-vars ()
    (cond
     ((string-equal system-type "darwin") ;  macOS
      (blw/set-macos-vars))
     ((string-equal system-type "gnu/linux")
      (blw/set-linux-vars))))

  (blw/set-system-specific-vars)
#+end_src

I use =use-package= to install and configure my packages. My =init.el= includes
the initial setup for =package.el= and ensures that =use-package= is installed,
since I wanna do that right away.

This makes sure that =use-package= will install the package if it's not already
available. It also means that I should be able to open Emacs for the first time
on a fresh Debian box and have my whole environment automatically installed. I'm
not /totally/ sure about that, but we're gettin' close.

# #+begin_src emacs-lisp
#   (require 'use-package-ensure)         ;
#   (setq use-package-always-ensure t)
# #+end_src

Always compile packages, and use the newest version available.

# #+begin_src emacs-lisp
#   (use-package! auto-compile
#     :config (auto-compile-on-load-mode))

#   (setq load-prefer-newer t)
# #+end_src

Disable TLS 1.3; ELPA has higher standards. That'll be the default in Emacs
26.3, I think, but I'm not there yet.

# #+begin_src emacs-lisp
#   (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
# #+end_src


Use [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] for some basic settings.

# #+begin_src emacs-lisp
#   (load-file "~/workspace/dotfiles/emacs/sensible-defaults.el/sensible-defaults.el")
#   (sensible-defaults/use-all-settings)
#   (sensible-defaults/use-all-keybindings)
#   (sensible-defaults/backup-to-temp-directory)
# #+end_src



#+begin_src emacs-lisp
  (setq user-full-name "Ben Weintraub"
        user-mail-address "ben@weintraub.xyz"
        calendar-latitude 42.35
        calendar-longitude -71.06
        calendar-location-name "Boston, MA")
#+end_src

# ** Access my netrc data

# I store a few credentials in a =.netrc= file. Actually, I think the only creds I
# have in there right now are for Instapaper, but this is still a convenient way
# to store not-too-terribly-sensitive secrets.

# #+begin_src emacs-lisp
#   (require 'netrc)

#   (setq netrc-file "~/.netrc")

#   (defun netrc-username (machine)
#     "Helper function to extract a username from my netrc."
#     (car (netrc-credentials machine)))

#   (defun netrc-password (machine)
#     "Helper function to extract a password from my netrc."
#     (cadr (netrc-credentials machine)))
# #+end_src


#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/resources/")
#+end_src


Define a big ol' bunch of handy utility functions.

#+begin_src emacs-lisp
  (defun hrs/rename-file (new-name)
    (interactive "FNew name: ")
    (let ((filename (buffer-file-name)))
      (if filename
          (progn
            (when (buffer-modified-p)
              (save-buffer))
            (rename-file filename new-name t)
            (kill-buffer (current-buffer))
            (find-file new-name)
            (message "Renamed '%s' -> '%s'" filename new-name))
        (message "Buffer '%s' isn't backed by a file!" (buffer-name)))))

  (defun hrs/generate-scratch-buffer ()
    "Create and switch to a temporary scratch buffer with a random
         name."
    (interactive)
    (switch-to-buffer (make-temp-name "scratch-")))

  (defun hrs/append-to-path (path)
    "Add a path both to the $PATH variable and to Emacs exec-path."
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))

  (defun hrs/notify-send (title message)
    "Display a desktop notification by shelling out to `notify-send'."
    (call-process-shell-command
     (format "notify-send -t 2000 \"%s\" \"%s\"" title message)))
#+end_src


I don't usually use the menu or scroll bar, and they take up useful space.

# #+begin_src emacs-lisp
#   (tool-bar-mode 0)
#   (menu-bar-mode 0)
#   (scroll-bar-mode -1)
# #+end_src

There's a tiny scroll bar that appears in the minibuffer window. This disables
that:

# #+begin_src emacs-lisp
#   (set-window-scroll-bars (minibuffer-window) nil nil)
# #+end_src

The default frame title isn't useful. This binds it to the name of the current
project:

#+begin_src emacs-lisp
  (setq frame-title-format '((:eval (projectile-project-name))))
#+end_src


Why not?

#+begin_src emacs-lisp
  (global-prettify-symbols-mode t)
#+end_src


I'm currently using the "solarized-dark" theme. I've got a scenic wallpaper, so
just a hint of transparency looks lovely and isn't distracting or hard to read.
I also use the interactive command =apply-light-theme= when the screen is hard
to see (like out in the sun).

#+begin_src emacs-lisp
  ;; (use-package solarized-theme
  ;;   :config
  ;;   (setq solarized-use-variable-pitch nil
  ;;         solarized-height-plus-1 1.0
  ;;         solarized-height-plus-2 1.0
  ;;         solarized-height-plus-3 1.0
  ;;         solarized-height-plus-4 1.0)

  ;;   (let ((line (face-attribute 'mode-line :underline)))
  ;;     (set-face-attribute 'mode-line          nil :overline   line)
  ;;     (set-face-attribute 'mode-line-inactive nil :overline   line)
  ;;     (set-face-attribute 'mode-line-inactive nil :underline  line)
  ;;     (set-face-attribute 'mode-line          nil :box        nil)
  ;;     (set-face-attribute 'mode-line-inactive nil :box        nil)
  ;;     (set-face-attribute 'mode-line-inactive nil :background "#f9f2d9")))
  (defun transparency (value)
    "Sets the transparency of the frame window. 0=transparent/100=opaque."
    (interactive "nTransparency Value 0 - 100 opaque:")
    (set-frame-parameter (selected-frame) 'alpha value))

  (defun blw/apply-dark-theme ()
    "Apply the `solarized-' theme and make frames just slightly transparent."
    (interactive)
    (setq doom-theme 'doom-one)
    (transparency 90))

  (defun blw/apply-light-theme ()
    "Apply the `solarized-' theme and make frames just slightly transparent."
    (interactive)
    (setq doom-theme 'doom-one-light)
    (transparency 90))

  (blw/apply-dark-theme)
#+end_src

If this code is being evaluated by =emacs --daemon=, ensure that each subsequent
frame is themed appropriately.

# #+begin_src emacs-lisp
#   (if (daemonp)
#       (add-hook 'after-make-frame-functions
#                 (lambda (frame)
#                   (with-selected-frame frame (blw/apply-dark-theme))))
#     (blw/apply-dark-theme))
# #+end_src


This gives me a truly lovely ribbon-based modeline.

# #+begin_src emacs-lisp
#   (use-package moody
#     :config
#     (setq x-underline-at-descent-line t
#           moody-mode-line-height 30)
#     (moody-replace-mode-line-buffer-identification)
#     (moody-replace-vc-mode))
# #+end_src


I never want to see a minor mode, and manually adding =:diminish= to every
use-package declaration is a hassle. This uses =minions= to hide all the minor
modes in the modeline. Nice!

By default there's a =;-)= after the major mode; that's an adorable default, but
I'd rather skip it.

# #+begin_src emacs-lisp
#    (use-package minions
#      :config
#      (setq minions-mode-line-lighter ""
#            minions-mode-line-delimiters '("" . ""))
#      (minions-mode 1))
# #+end_src

#+begin_src emacs-lisp
  (setq display-time-day-and-date t)
  (display-time)
#+end_src


=sensible-defaults= replaces the audible bell with a visual one, but I really
don't even want that (and my Emacs/Mac pair renders it poorly). This disables
the bell altogether.

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src


When point goes outside the window, Emacs usually recenters the buffer point.
I'm not crazy about that. This changes scrolling behavior to only scroll as far
as point goes.

#+begin_src emacs-lisp
  (setq scroll-conservatively 100)
#+end_src


I'm partial to Inconsolata.

The standard =text-scale-= functions just resize the text in the current buffer;
I'd generally like to resize the text in /every/ buffer, and I usually want to
change the size of the modeline, too (this is especially helpful when
presenting). These functions and bindings let me resize everything all together!

Note that this overrides the default font-related keybindings from
=sensible-defaults=.

#+begin_src emacs-lisp
  (setq hrs/default-font "Inconsolata")
  (setq hrs/default-font-size 24)
  (setq hrs/current-font-size hrs/default-font-size)

  (setq hrs/font-change-increment 1.1)

  (defun hrs/font-code ()
    "Return a string representing the current font (like \"Inconsolata-14\")."
    (concat hrs/default-font "-" (number-to-string hrs/current-font-size)))

  (defun hrs/set-font-size ()
    "Set the font to `hrs/default-font' at `hrs/current-font-size'.
  Set that for the current frame, and also make it the default for
  other, future frames."
    (let ((font-code (hrs/font-code)))
      (if (assoc 'font default-frame-alist)
          (setcdr (assoc 'font default-frame-alist) font-code)
        (add-to-list 'default-frame-alist (cons 'font font-code)))
      (set-frame-font font-code)))

  (defun hrs/reset-font-size ()
    "Change font size back to `hrs/default-font-size'."
    (interactive)
    (setq hrs/current-font-size hrs/default-font-size)
    (hrs/set-font-size))

  (defun hrs/increase-font-size ()
    "Increase current font size by a factor of `hrs/font-change-increment'."
    (interactive)
    (setq hrs/current-font-size
          (ceiling (* hrs/current-font-size hrs/font-change-increment)))
    (hrs/set-font-size))

  (defun hrs/decrease-font-size ()
    "Decrease current font size by a factor of `hrs/font-change-increment', down to a minimum size of 1."
    (interactive)
    (setq hrs/current-font-size
          (max 1
               (floor (/ hrs/current-font-size hrs/font-change-increment))))
    (hrs/set-font-size))

  (define-key global-map (kbd "C-)") 'hrs/reset-font-size)
  (define-key global-map (kbd "C-+") 'hrs/increase-font-size)
  (define-key global-map (kbd "C-=") 'hrs/increase-font-size)
  (define-key global-map (kbd "C-_") 'hrs/decrease-font-size)
  (define-key global-map (kbd "C--") 'hrs/decrease-font-size)

  (hrs/reset-font-size)
#+end_src


=global-hl-line-mode= softly highlights the background color of the line
containing point. It makes it a bit easier to find point, and it's useful when
pairing or presenting code.

#+begin_src emacs-lisp
  (global-hl-line-mode)
#+end_src


Use the =diff-hl= package to highlight changed-and-uncommitted lines when
programming.

#+begin_src emacs-lisp
  (use-package! diff-hl
    :config
    (add-hook 'prog-mode-hook 'turn-on-diff-hl-mode)
    (add-hook 'vc-dir-mode-hook 'turn-on-diff-hl-mode))
#+end_src

# ** Buffer swapping
# Swap buffers with =C-S-<D-PAD DIRECTION>=

# #+begin_src emacs-lisp
#   (require 'buffer-move)
#   (global-set-key (kbd "<C-S-up>")     'buf-move-up)
#   (global-set-key (kbd "<C-S-down>")   'buf-move-down)
#   (global-set-key (kbd "<C-S-left>")   'buf-move-left)
#   (global-set-key (kbd "<C-S-right>")  'buf-move-right)
# #+end_src

I prefer =IBuffer=, and have it mapped to =C-x C-b=

#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-b") 'ibuffer)
(autoload 'ibuffer "ibuffer" "List buffers." t)
#+end_src

Make full screen on startup, because this is the first thing I'm going to do anyway.

#+begin_src emacs-lisp
  (set-frame-parameter nil 'fullscreen 'maximized)
#+end_src


I use a few packages in virtually every programming or writing environment to
manage the project, handle auto-completion, search for terms, and deal with
version control. That's all in here.


Install =ag= to provide search within projects (usually through
=projectile-ag=).

# #+begin_src emacs-lisp
#   (use-package ag)
# #+end_src


Install =avy= to skip around the screen quickly.

# #+begin_src emacs-lisp
#   (use-package avy
#     :bind*
#     ("C-;" . evil-avy-goto-char-2))
# #+end_src


Use =company-mode= everywhere.

# #+begin_src emacs-lisp
#   (use-package company)
#   (add-hook 'after-init-hook 'global-company-mode)
# #+end_src

Use =M-/= for completion.

#+begin_src emacs-lisp
  (global-set-key (kbd "M-/") 'company-complete-common)
#+end_src


The =dumb-jump= package works well enough in a [[https://github.com/jacktasia/dumb-jump#supported-languages][ton of environments]], and it
doesn't require any additional setup. I've bound its most useful command to
=M-.=.

#+begin_src emacs-lisp
  (use-package! dumb-jump                ;
    :config
    (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
    (setq dumb-jump-selector 'ivy))
#+end_src


I'd like to enable flycheck all kinds of places.

#+begin_src emacs-lisp
  (use-package! let-alist)
  (use-package! flycheck)
#+end_src

Correct flycheck-identified mistakes.
#+begin_src emacs-lisp
  (use-package! attrap
    :ensure t)
#+end_src


I use =magit= to handle version control. It's lovely, but I tweak a few things:

- I bring up the status menu with =C-c m=.
- The default behavior of =magit= is to ask before pushing. I haven't had any
  problems with accidentally pushing, so I'd rather not confirm that every time.
- Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
  beyond 50 characters.
- I'd like to start in the insert state when writing a commit message.

#+begin_src emacs-lisp
  (use-package! magit
    :bind
    ("C-c m" . magit-status)

    :config
    (use-package with-editor)

    (setq magit-push-always-verify nil
          git-commit-summary-max-length 50))
#+end_src


Projectile's default binding of =projectile-ag= to =C-c p s s= is clunky enough
that I rarely use it (and forget it when I need it). This binds it to the
easier-to-type =C-c v= to useful searches.

Bind =C-p= to fuzzy-finding files in the current project. We also need to
explicitly set that in a few other modes.

I use =ivy= as my completion system.

When I visit a project with =projectile-switch-project=, the default action is
to search for a file in that project. I'd rather just open up the top-level
directory of the project in =dired= and find (or create) new files from there.

I'd like to /always/ be able to recursively fuzzy-search for files, not just
when I'm in a Projectile-defined project. I use the current directory as a
project root (if I'm not in a "real" project).

#+begin_src emacs-lisp
  (use-package! projectile
    :bind
    ("C-c v" . projectile-ag)

    :config
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)

    (setq projectile-completion-system 'ivy
          projectile-switch-project-action 'projectile-dired
          projectile-require-project-root nil))
#+end_src

I like tree-based undo management. I only rarely need it, but when I do, oh boy.

#+begin_src emacs-lisp
  (use-package undo-tree)
#+end_src


I like shallow indentation, but tabs are displayed as 8 characters by default.
This reduces that.

#+begin_src emacs-lisp
  (setq-default tab-width 2)
#+end_src

Treating terms in CamelCase symbols as separate words makes editing a little
easier for me, so I like to use =subword-mode= everywhere.

#+begin_src emacs-lisp
  (use-package! subword
    :config (global-subword-mode 1))
#+end_src

Compilation output goes to the =*compilation*= buffer. I rarely have that window
selected, so the compilation output disappears past the bottom of the window.
This automatically scrolls the compilation window so I can always see the
output.

#+begin_src emacs-lisp
  (setq compilation-scroll-output t)
#+end_src

#+begin_src emacs-lisp
  (setq scss-compile-at-save nil)
#+end_src


# Install =go-mode= and related packages:

# #+begin_src emacs-lisp
#   (use-package go-mode)
#   (use-package go-errcheck)
#   (use-package company-go)
# #+end_src

# Define my =$GOPATH= and tell Emacs where to find the Go binaries.

# #+begin_src emacs-lisp
#   (setenv "GOPATH" "~/workspace/go")
#   (hrs/append-to-path (concat (getenv "GOPATH") "/bin"))
# #+end_src

Run =goimports= on every file when saving, which formats the file and
automatically updates the list of imports. This requires that the =goimports=
binary be installed.

# #+begin_src emacs-lisp
#  (setq gofmt-command "goimports")
#  (add-hook 'before-save-hook 'gofmt-before-save)
# #+end_src
#+begin_src emacs-lisp

#+end_src
When I open a Go file,

- Start up =company-mode= with the Go backend. This requires that the =gocode=
  binary is installed,
- Redefine the default =compile= command to something Go-specific, and
- Enable =flycheck=.

# #+begin_src emacs-lisp
#   (add-hook! 'go-mode-hook              ;
#             (lambda ()
#               (set (make-local-variable 'company-backends)
#                    '(company-go))
#               (company-mode)
#               (if (not (string-match "go" compile-command))
#                   (set (make-local-variable 'compile-command)
#                        "go build -v && go test -v && go vet"))
#               (flycheck-mode)))
# #+end_src


# #+begin_src emacs-lisp
#   (use-package haskell-mode)            ;
# #+end_src

# Enable =haskell-doc-mode=, which displays the type signature of a function, and
# use smart indentation.

# #+begin_src emacs-lisp
#   (add-hook 'haskell-mode-hook
#             (lambda ()
#               (haskell-doc-mode)
#               (turn-on-haskell-indent)))
# #+end_src

# #+begin_src emacs-lisp
#   (hrs/append-to-path "~/.cabal/bin")
# #+end_src

# #+begin_src emacs-lisp
# 	(use-package dante
# 		:ensure t
# 		:after haskell-mode
# 		:commands 'dante-mode
# 		:init
# 		;; (add-hook 'haskell-mode-hook 'flycheck-mode)
# 		;; OR for flymake support:
# 		;; (add-hook 'haskell-mode-hook 'flymake-mode)
# 		;; (remove-hook 'flymake-diagnostic-functions 'flymake-proc-legacy-flymake)
# 		(add-hook 'haskell-mode-hook 'dante-mode)
# 		;; (define-key dante-mode-map (kbd "C-c C-c") 'dante-eval-block)
# 		)


# #+end_src


# Install =coffee-mode= from editing CoffeeScript code.

# #+begin_src emacs-lisp
#   (use-package coffee-mode)
# #+end_src

# Indent everything by 2 spaces.

# #+begin_src emacs-lisp
#   (setq js-indent-level 2)

#   (add-hook 'coffee-mode-hook
#             (lambda ()
#               (yas-minor-mode 1)
#               (setq coffee-tab-width 2)))
# #+end_src



# #+begin_src emacs-lisp
#   (use-package racket-mode)
# #+end_src

# [[https://docs.racket-lang.org/pollen/][Pollen]] uses a lozenge ◊ to mark preprocessor commands (like defining and
# dereferencing variables). That's awkward to type, so this lets me hit =M-^= to
# insert one.

# #+begin_src emacs-lisp
#   (defun hrs/insert-lozenge ()
#     (interactive)
#     (insert "◊"))

#   (define-key racket-mode-map (kbd "M-^") 'hrs/insert-lozenge)
# #+end_src



All the lisps have some shared features, so we want to do the same things for
all of them. That includes using =paredit=, =rainbow-delimiters=, and
highlighting the whole expression when point is on a parenthesis.

#+begin_src emacs-lisp
  (setq lispy-mode-hooks
        '(clojure-mode-hook
          emacs-lisp-mode-hook
          lisp-mode-hook
          scheme-mode-hook))

  (dolist (hook lispy-mode-hooks)
    (add-hook hook (lambda ()
                     (setq show-paren-style 'expression)
                     (paredit-mode)
                     (rainbow-delimiters-mode))))
#+end_src

If I'm writing in Emacs lisp I'd like to use =eldoc-mode= to display
documentation.

#+begin_src emacs-lisp
  (use-package! eldoc
    :config
    (add-hook! 'emacs-lisp-mode-hook 'eldoc-mode))
#+end_src

# #+begin_src emacs-lisp
#   (use-package python-mode)
# #+end_src

# Add a thin vertical line at 80 characters for python files. From
# =fill-column-indicator=.
# #+begin_src emacs-lisp
#   (add-hook 'python-mode-hook 'fci-mode)
# #+end_src

# Add =~/.local/bin= to load path. That's where =virtualenv= is installed, and
# we'll need that for =jedi=.

# #+begin_src emacs-lisp
#   (hrs/append-to-path "~/.local/bin")
# #+end_src

# Enable =elpy=. This provides automatic indentation, auto-completion, syntax
# checking, etc.

# #+begin_src emacs-lisp
#   (use-package elpy)
#   (elpy-enable)
# #+end_src

# Use =flycheck= for syntax checking:

# #+begin_src emacs-lisp
#   (add-hook 'elpy-mode-hook 'flycheck-mode)
# #+end_src

# Format code according to PEP8 on save:

# #+begin_src emacs-lisp
#   (use-package py-autopep8)
#   (require 'py-autopep8)
#   (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
# #+end_src


Indent with 2 spaces.

#+begin_src emacs-lisp
  (add-hook! 'sh-mode-hook
            (lambda ()
              (setq sh-basic-offset 2
                    sh-indentation 2)))
#+end_src

#+begin_src emacs-lisp
  (eshell-git-prompt-use-theme 'robbyrussell)
#+end_src
Automagically do an =ls= when entering a new directory.

#+begin_src emacs-lisp
(setq eshell-list-files-after-cd t)
#+end_src

Open new eshell prompt with =F1= key.

#+begin_src emacs-lisp
  (global-set-key [f1] 'eshell)
#+end_src

Add some fun tools for viewing shell history and finding files.

#+begin_src emacs-lisp
  (add-hook! 'eshell-mode-hook
    (lambda ()
      (define-key eshell-mode-map (kbd "C-c C-i") 'helm-eshell-history)))

  (add-hook! 'eshell-mode-hook
    (lambda ()
      (define-key eshell-mode-map (kbd "C-c C-f") 'helm-find-files)))
#+end_src

Emacs shells should inherit the PATH from the system shell.

#+begin_src emacs-lisp
  (use-package! exec-path-from-shell
    :if (memq window-system '(mac ns))
    :ensure t
    :config
    ;;(exec-path-from-shell-check-startup-files nil)
    (exec-path-from-shell-initialize))
#+end_src


Including =org-tempo= restores the =<s=-style easy-templates that were
deprecated in Org 9.2.

I'd like to open =file:= links in Org with the applications defined in my
[[file:~/.dotfiles/email/.mailcap][mailcap]]. This clears the existing MIME mapping, parses my personal mailcap, and
tells Org to open those links with the mailcap-defined applications.

# #+begin_src emacs-lisp
#   (after! org
#     (require 'org-tempo))
# #+end_src

# #+begin_src emacs-lisp
#   (use-package org
#     :ensure org-plus-contrib
#     :config
#

#     (add-hook 'org-mode-hook
#               '(lambda ()
#                  (setq mailcap-mime-data '())
#                  (mailcap-parse-mailcap "~/.mailcap")
#                  (setq org-file-apps
#                        '((remote . emacs)
#                          ("mobi" . "fbreader %s")
#                          (system . mailcap)
#                          ("md" . emacs)
#                          ("org" . emacs)
#                          (t . mailcap))))))
# #+end_src

I'd like the initial scratch buffer to be in Org:

#+begin_src emacs-lisp
  (setq initial-major-mode 'org-mode)
#+end_src


Images should be shown in-buffer by default, but not at full size.

#+begin_src emacs-lisp
  (setq org-startup-with-inline-images t)
  (setq org-image-actual-width nil)
#+end_src


Use =notmuch= to read my email.
#+begin_src emacs-lisp
  (use-package! notmuch)

  (after! notmuch
    (set-popup-rule! "^\\*notmuch-hello" :size 40 :side 'left :ttl 0))

  (setq mail-host-address "gmail.com"
        mail-user-agent 'message-user-agent
        message-send-mail-function 'message-send-mail-with-sendmail
        message-kill-buffer-on-exit t
        mail-specify-envelope-from t
        sendmail-program "msmtp"
        mail-envelope-from 'header
        message-sendmail-envelope-from 'header

        ;; add Cc and Bcc headers to the message buffer
        message-default-mail-headers "Cc: \nBcc: \n")

  (setq notmuch-saved-searches
        '((:name "slimbox"
                 :query "tag:unread AND NOT tag:scholarly-reading AND NOT tag:calnewport AND NOT tag:newyorker AND NOT tag:lightning-dev AND NOT tag:nu-unread"
                 :key "i"
                 :sort-order newest-first
                 :search-type 'tree)
          (:name "inbox" :query "tag:inbox" :sort-order newest-first :search-type 'tree)
          (:name "unread" :query "tag:unread" :key "u" :sort-order newest-first :search-type 'tree)
          (:name "nu-unread" :query "to:weintraub.b@northeastern.edu AND tag:unread", :key "nu" :sort-order newest-first :search-type 'tree)
          (:name "calnewport" :query "tag:calnewport AND tag:unread" :key "cn" :sort-order newest-first :search-type 'tree)
          (:name "lightning-dev" :query "tag:lightning-dev AND tag:unread" :sort-order newest-first :key "l" :search-type 'tree)
          (:name "newyorker" :query "tag:newyorker AND tag:unread" :sort-order newest-first :key "ny" :search-type 'tree)
          (:name "scholarly-reading" :query "tag:scholarly-reading AND tag:unread" :sort-order newest-first :key "s" :search-type 'tree)
          (:name "the-economist" :query "tag:economist AND tag:unread" :sort-order newest-first :key "e" :search-type 'tree)))

  (define-key notmuch-search-mode-map "R"
    (lambda (&optional beg end)
      "mark read"
      (interactive (notmuch-interactive-region))
      (notmuch-search-tag (list "-unread" "-new") beg end)))

  (define-key notmuch-search-mode-map "d"
    (lambda (&optional beg end)
      "Delete me"
      (interactive (notmuch-interactive-region))
      (notmuch-search-tag (list "-unread" "-inbox" "-new" "+delete") beg end)))

  (define-key notmuch-search-mode-map "U"
    (lambda (&optional beg end)
      "Mark unread"
      (interactive (notmuch-interactive-region))
      (notmuch-search-tag (list "+unread") beg end)))

  (define-key notmuch-search-mode-map "S"
    (lambda (&optional beg end)
      "Mark unread"
      (interactive (notmuch-interactive-region))
      (notmuch-search-tag (list "+spam" "-inbox" "-new") beg end)))

  (require 'ol-notmuch)

  (setq message-kill-buffer-on-exit t)

  (defvar notmuch-hello-refresh-count 0)

  (defun notmuch-hello-refresh-status-message ()
    (unless no-display
      (let* ((new-count
              (string-to-number
               (car (process-lines notmuch-command "count"))))
             (diff-count (- new-count notmuch-hello-refresh-count)))
        (cond
         ((= notmuch-hello-refresh-count 0)
          (message "You have %s messages."
                   (notmuch-hello-nice-number new-count)))
         ((> diff-count 0)
          (message "You have %s more messages since last refresh."
                   (notmuch-hello-nice-number diff-count)))
         ((< diff-count 0)
          (message "You have %s fewer messages since last refresh."
                   (notmuch-hello-nice-number (- diff-count)))))
        (setq notmuch-hello-refresh-count new-count))))

  (add-hook 'notmuch-hello-refresh-hook 'notmuch-hello-refresh-status-message)
#+end_src


I like to see an outline of pretty bullets instead of a list of asterisks.
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'org-bullets-mode)
#+end_src

I like seeing a little downward-pointing arrow instead of the usual ellipsis
(=...=) that org displays when there's stuff under a header.

#+begin_src emacs-lisp
  (setq org-ellipsis "⤵")
#+end_src

Use syntax highlighting in source blocks while editing.

#+begin_src emacs-lisp
  (setq org-src-fontify-natively t)
#+end_src

Make TAB act as if it were issued in a buffer of the language's major mode.

#+begin_src emacs-lisp
  (setq org-src-tab-acts-natively t)
#+end_src

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+begin_src emacs-lisp
  (setq org-src-window-setup 'current-window)
#+end_src

Quickly insert a block of =elisp= or =jupyter-python=.

#+begin_src emacs-lisp
  (after! org
    (add-to-list 'org-structure-template-alist
                 '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist
                 '("jp" . "src jupyter-python :async yes :exports code :results code")))
#+end_src

Don't indent newly expanded blocks, even if they're under a heading.

#+begin_src emacs-lisp
  (setq org-adapt-indentation nil)
#+end_src

Show Greek letters and =LaTeX= math symbols (in =org= buffer) using normal
=LaTeX= syntax.
#+begin_src emacs-lisp
  (setq org-pretty-entities t)
#+end_src

Store my org files in =~/Dropbox/org=, maintain an inbox in Dropbox, define
the location of an index file (my main todo list).

#+begin_src emacs-lisp
  (defun blw/full-file-path (directory filename)
    "Return the absolute path of a file, given its filename and the directory it's in."
    (concat (file-name-as-directory directory) filename))

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (blw/full-file-path org-directory filename))

  (defun blw/persistent-file-path (filename)
    "Return the absolute address of a file in whatever persistent storage I'm using, given its relative name."
    (blw/full-file-path blw/org-persistent-directory filename))

  (setq blw/org-persistent-directory "~/Dropbox/")
  (setq org-directory (blw/persistent-file-path "org"))
  (setq org-index-file (org-file-path "todos.org"))
  (setq org-gcal-file (org-file-path "schedule.org"))
  (setq blw/org-reading-file (org-file-path "reading.org"))
  (setq blw/org-fun-projects-file (org-file-path "fun-projects.org"))
  (setq blw/org-zettel-inbox-file (org-file-path "zettel-inbox.org"))
#+end_src

I store everything in a single file called =thebigone.org=. If I
decide to store events or tasks in additional files in the future, I can easily
do so by adding more =org-file-path= S-expressions to the list.

#+begin_src emacs-lisp
  (setq org-agenda-files (list org-index-file
                               blw/org-reading-file))
#+end_src

Record the time that a todo was completed.

#+begin_src emacs-lisp
  (setq org-log-done 'time)
#+end_src

Ensure that a task can't be marked as done if it contains unfinished subtasks or
checklist items. This is handy for organizing "blocking" tasks hierarchically.

#+begin_src emacs-lisp
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
#+end_src

Begin weeks /today/, not on the last Monday.

#+begin_src emacs-lisp
  (setq org-agenda-start-on-weekday nil)
#+end_src

Hide the category prefix from tasks. In practice, I've usually only got one or
two files of tasks, so prefixing tasks with the file they're stored in is mostly
redundant.

#+begin_src emacs-lisp
  (setq org-agenda-prefix-format '((agenda . " %i %?-12t% s")
                                   (todo . " %i ")
                                   (tags . " %i ")
                                   (search . " %i ")))
#+end_src

Restore the previous window setup after agenda is exited, and when the agenda is
opened, it should split the pane and open in the new pane without disturbing the
prior pane.
#+begin_src emacs-lisp
  (after! org
          (setq org-agenda-restore-windows-after-quit t
                org-agenda-window-setup 'other-window
                org-agenda-skip-scheduled-if-deadline-is-shown t
                org-agenda-skip-deadline-if-done t
                org-agenda-span 'week
                org-agenda-start-day nil))
#+end_src
I've got some custom agenda views that I use to visualize what I'm working on.

The "Personal agenda" view is a bit complicated; it displays:

1. My agenda for the next few days, including any recurring habits or scheduled
   events,
2. All the other, not-high-priority non-habit TODO items,
3. All the PENDING tasks, which are awaiting a response from someone else but
   still require my attention (I might need to ping someone, say), and
4. All the BLOCKED tasks, which are pending other tasks (but might be worth
   keeping an eye on anyway).

I effectively use the "A" priority to decide where I want to focus my attention
on a given day (I'll assign those priorities the night before, if I'm really on
top of things), so displaying them at the top makes sense.

A lot of this is based on [[https://blog.aaronbieber.com/2016/09/24/an-agenda-for-life-with-org-mode.html][Aaron Bieber's agenda configuration]], including the
=skip-subtree-if-priority= and =skip-subtree-if-habit= functions, which I've
shamelessly stolen and re-prefixed.

#+begin_src emacs-lisp
  (defun hrs/org-skip-subtree-if-priority (priority)
    "Skip an agenda subtree if it has a priority of PRIORITY.

  PRIORITY may be one of the characters ?A, ?B, or ?C."
    (let ((subtree-end (save-excursion (org-end-of-subtree t)))
          (pri-value (* 1000 (- org-lowest-priority priority)))
          (pri-current (org-get-priority (thing-at-point 'line t))))
      (if (= pri-value pri-current)
          subtree-end
        nil)))

  (defun hrs/org-skip-subtree-if-habit ()
    "Skip an agenda entry if it has a STYLE property equal to \"habit\"."
    (let ((subtree-end (save-excursion (org-end-of-subtree t))))
      (if (string= (org-entry-get nil "STYLE") "habit")
          subtree-end
        nil)))

  (setq org-agenda-custom-commands
        '(("p" "Personal agenda"
           ((agenda "")
            (todo "TODO"
                  ((org-agenda-skip-function '(or (org-agenda-skip-subtree-if 'scheduled)
                                                  (org-agenda-skip-subtree-if 'deadline)))
                   (org-agenda-overriding-header "Other tasks:")))
            (todo "INPROGRESS"
                  ((org-agenda-overriding-header "In progress:")))
            (todo "READ|SKIM|NOTES"
                  ((org-agenda-overriding-header "Reading:")))
            (todo "VET"
                  ((org-agenda-overriding-header "Vetting:")))))))
#+end_src

I consult my agenda pretty often, so I bind =C-c d= to open it a it faster. This
also copies any files I've sent through Drafts into my index file before
displaying the index, so they'll be in the agenda view, too.

#+begin_src emacs-lisp
  (defun hrs/dashboard ()
    (interactive)
    (org-agenda nil "p"))

  (global-set-key (kbd "C-c d") 'hrs/dashboard)
#+end_src

A nice visualizer for my =org-roam= graph.
#+begin_src emacs-lisp
  (setq org-roam-server-host "127.0.0.1"
        org-roam-server-port 8080
        org-roam-server-authenticate nil
        org-roam-server-export-inline-images t
        org-roam-server-serve-files nil
        org-roam-server-served-file-extensions '("pdf" "mp4" "ogv")
        org-roam-server-network-poll t
        org-roam-server-network-arrows nil
        org-roam-server-network-label-truncate t
        org-roam-server-network-label-truncate-length 60
        org-roam-server-network-label-wrap-length 20)
#+end_src

My [[https://zettelkasten.de/][Zettelkasten]] setup with [[https://www.orgroam.com/][org-roam]].
#+begin_src emacs-lisp
  (defun blw/org-roam-graph-firefox (graph)
    (org-roam-server-mode t)
    (shell-command (concat blw/open-firefox " http://127.0.0.1:8080")))

  (defun blw/get-string-from-file (filePath)
    "Return filePath's file content."
    (concat (with-temp-buffer
              (insert-file-contents filePath)
              (buffer-string))))

  (after! org-roam
    (setq org-roam-directory (blw/persistent-file-path "zettelkasten")
          org-roam-db-update-method 'immediate
          org-roam-graph-executable "dot"
          org-roam-graph-shorten-titles 'wrap
          org-roam-graph-max-title-length 50
          org-roam-graph-viewer 'blw/org-roam-graph-firefox
          org-roam-graph-extra-config '(("overlap" . "no"))
          org-roam-graph-exclude-matcher '("index" "daily")
          org-roam-graph-executable "neato"
          org-roam-dailies-directory "daily/"
          emacsql-sqlite3-executable (executable-find "sqlite3")
          org-roam-dailies-capture-templates
           '(("x" "default" entry
             #'org-roam-capture--get-point
             "* %?"
             :file-name "daily/%<%Y-%m-%d>"
             :head "#+title: %<%Y-%m-%d>\n\n")))

    (map! :map org-roam-mode-map
         (:prefix ("C-c n" . "org-roam")
           :desc "View backlinks" "l" #'org-roam
           :desc "Find file"      "f" #'org-roam-find-file
           :desc "Graph"          "g" #'org-roam-graph
           :desc "Today"          "d" #'org-roam-dailies-find-today
           :desc "Tomorrow"       "t" #'org-roam-dailies-find-tomorrow
           :desc "Yesterday"      "y" #'org-roam-dailies-find-yesterday
           :desc "Anyday"         "a" #'org-roam-dailies-find-date))

    (map! :map org-mode-map
          (:prefix ("C-c n" . "org-roam")
          :desc "Insert immediate link" "I" #'org-roam-insert-immediate
          :desc "Unlink"                "u" #'org-link-at-point-unlink
          :desc "Insert"                "i" #'org-roam-insert)))

  (add-hook! org-roam-mode (org-roam-bibtex-mode))

;;  (require 'org-roam-protocol)


  (require 'subr-x) ;; for `when-let'

  (defun org-link-at-point-unlink ()
    "Replace link at point with description."
    (interactive)
    (when-let ((el (org-element-context))
           (b (and (eq (org-element-type el) 'link)
               (org-element-property :contents-begin el)))
           (e (org-element-property :contents-end el))
           (contents (buffer-substring-no-properties b e))
           (b (org-element-property :begin el))
           (e (org-element-property :end el)))
      (delete-region b e)
      (insert contents)))
#+end_src

This is for me to generate my weekly plans.
#+begin_src emacs-lisp
  (defun blw/weekly-plan--day-splits (n)
    (split-window-vertically)
    ;; (other-window 1)
    (org-roam-dailies-find-tomorrow n)
    (balance-windows))

  (defun blw/weekly-plan ()
    (interactive)
    (delete-other-windows)
    (hrs/dashboard)
    (other-window 1)
    (org-roam-dailies-find-today)
    (blw/weekly-plan--day-splits 1)
    (blw/weekly-plan--day-splits 2)
    (blw/weekly-plan--day-splits 3)
    (blw/weekly-plan--day-splits 4))
#+end_src
Use this to take screenshots and embed them in =org= files. Note that
=screencapture= is the tool to use for MacOS. Though =org-download= supports
other tools for other OSs.
#+begin_src emacs-lisp
  (setq org-download-screenshot-method blw/screenshot)
  (setq org-download-image-dir "screenshots/")
  (setq org-download-image-org-width 500)
  (setq org-download-heading-lvl nil)
#+end_src

#+begin_src emacs-lisp
  (setq reftex-default-bibliography '((blw/persistent-file-path "zettelkasten/references.bib")))

  ;; see org-ref for use of these variables
  (setq org-ref-bibliography-notes "~/Dropbox/zettelkasten/notes.org"
        org-ref-default-bibliography '("~/Dropbox/zettelkasten/references.bib")
        org-ref-pdf-directory "~/Dropbox/zettelkasten/bibtex-pdfs/")

  (setq bibtex-completion-bibliography "~/Dropbox/zettelkasten/references.bib"
        bibtex-completion-library-path "~/Dropbox/zettelkasten/bibtex-pdfs"
        bibtex-completion-notes-path "~/Dropbox/zettelkasten/helm-bibtex-notes")

;;  (bibtex-set-dialect 'biblatex)
#+end_src

More meta-data for my annotated bibliography.
#+begin_src emacs-lisp
  (use-package! org-roam-bibtex
    :after org-roam
    :hook (org-roam-mode . org-roam-bibtex-mode))
#+end_src

Higher resolution on PDFs.
#+begin_src emacs-lisp
  (setq doc-view-resolution 192)
#+end_src


Define a few common tasks as capture templates. Specifically, I frequently:

- Add things I might want to read to =reading.org=
- Add website/CV updates
- Add ideas for zettelkasten notes
- Probably more in the future...

#+begin_src emacs-lisp
  (after! org
          (setq org-capture-templates nil)
          (setq org-capture-templates
                '(("r" "Reading material"
                   entry
                   (file blw/org-reading-file)
                   "* %?\n")
                  ("c" "CV/Website updates"
                   entry
                   (file "~/Dropbox/org/cv-website.org")
                   "* %?\n")
                  ("z" "Zettel inbox"
                   entry
                   (file blw/org-zettel-inbox-file)
                   "* %?\n")
                  ("t" "TODO inbox"
                   entry
                   (file org-index-file)
                   "* TODO %?\n")
                  ("f" "Fun projects"
                   entry
                   (file blw/org-fun-projects-file)
                   "* %?\n"))))
#+end_src

I want to be able to quickly open up my list of zettel topics.

#+begin_src emacs-lisp
  (defun blw/zettel-topics ()
    (interactive)
    (find-file blw/org-zettel-inbox-file))

  (defun blw/todos ()
    (interactive)
    (find-file org-index-file))

  (defun blw/fun-projects ()
    (interactive)
    (find-file blw/org-fun-projects-file))

  (defun blw/reading-list ()
    (interactive)
    (find-file blw/org-reading-file))
#+end_src

Refiling according to the document's hierarchy.

#+begin_src emacs-lisp
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)
#+end_src


Bind a few handy keys.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c c") 'org-capture)
#+end_src

# Setup Google calendar syncing. To get credentials, following instructions [[https://github.com/kidd/org-gcal.el#Installation][here]].
# =org-gcal-client-secret= must also be set, I'm doing this in
# =configuration-private.org=.

# #+begin_src emacs-lisp
#   (use-package org-gcal)
#   (setq org-gcal-client-id "181983013000-81k9jtbk9th1up1qfue271jgo1ksp2gf.apps.googleusercontent.com"
#         org-gcal-file-alist '(("benweintraub34@gmail.com" . "~/Dropbox/org/schedule.org")))
# #+end_src

Don't ask me if canceled events should be removed. They should.

#+begin_src emacs-lisp
  (setq org-gcal-remove-api-cancelled-events t)
#+end_src


Allow =babel= to evaluate Emacs lisp, Python, IPython, or Shell code.

#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (shell . t)

     ;; needed for graphviz
     (dot . t)))
#+end_src

Don't ask before evaluating code blocks.

#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src

#+begin_src emacs-lisp
  (use-package pyvenv)
#+end_src

Display/update images in the buffer after I evaluate.
#+begin_src emacs-lisp
  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
#+end_src


Allow export to markdown and beamer (for presentations).

#+begin_src emacs-lisp
  (use-package! ox-twbs)
  (require 'ox-md)
  (require 'ox-beamer)
  (require 'ox-twbs)
#+end_src

Use =htmlize= to ensure that exported code blocks use syntax highlighting.

#+begin_src emacs-lisp
  (use-package! htmlize)
#+end_src

Translate regular ol' straight quotes to typographically-correct curly quotes
when exporting.

#+begin_src emacs-lisp
  (setq org-export-with-smart-quotes t)
#+end_src


Don't include a footer with my contact and publishing information at the bottom
of every exported HTML document.

#+begin_src emacs-lisp
  (setq org-html-postamble nil)
#+end_src

Some of the style elements are off if these two aren't set to =css=.
#+begin_src emacs-lisp
  (setq org-html-htmlize-output-type 'inline-css)
  (setq org-twbs-htmlize-output-type 'inline-css)
#+end_src


I want to produce PDFs with syntax highlighting in the code. The best way to do
that seems to be with the =minted= package, but that package shells out to
=pygments= to do the actual work. =pdflatex= usually disallows shell commands;
this enables that.

#+begin_src emacs-lisp
  (setq org-latex-pdf-process
        '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "bibtex %b"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+end_src

Include the =minted= package in all of my LaTeX exports.

#+begin_src emacs-lisp
  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-latex-listings 'minted)
#+end_src

Put LaTeX table captions below the table.

#+begin_src emacs-lisp
  (setq org-latex-caption-above nil)
#+end_src

Use =org-reveal= to export =org= documents as =reveal.js= slide decks. This is integrated in the
export menu. Documentation and details [[https://github.com/yjwen/org-reveal][here]].

#+begin_src emacs-lisp
  (use-package! ox-reveal
    :config
    (setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js"))
#+end_src


I rarely write LaTeX directly any more, but I often export through it with
org-mode, so I'm keeping them together.

Automatically parse the file after loading it.

#+begin_src emacs-lisp
  (setq TeX-parse-self t)
#+end_src

Always use =pdflatex= when compiling LaTeX documents. I don't really have any
use for DVIs.

#+begin_src emacs-lisp
  (setq TeX-PDF-mode t)
#+end_src

Enable a minor mode for dealing with math (it adds a few useful keybindings),
and always treat the current file as the "main" file. That's intentional, since
I'm usually actually in an org document.

#+begin_src emacs-lisp
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (LaTeX-math-mode)
              (setq TeX-master t)))
#+end_src

Start a new line when line length exceeds 80 characters.

#+begin_src
(add-hook 'LaTeX-mode-hook 'auto-fill-mode)
#+end_src


I write prose in several modes: I might be editing an Org document, or a commit
message, or an email. These are the main ones, with sub-items being /derived/
from their parents:

- =git-commit-mode=
- =text-mode=
  - =markdown-mode=
    - =gfm-mode=
  - =message-mode=
    - =mu4e-compose-mode=
  - =org-mode=

Recall that derived modes "inherit" their parent's hooks, so a hook added onto
e.g. =text-mode= will also be executed by =mu4e-compose-mode=.

There are some exceptions, but I can usually associate a hook with every
prose-related mode, so I store those in a list:

#+begin_src emacs-lisp
  (defvar prose-modes
    '(gfm-mode
      git-commit-mode
      markdown-mode
      message-mode
      mu4e-compose-mode
      org-mode
      text-mode))

  (defvar prose-mode-hooks
    (mapcar (lambda (mode) (intern (format "%s-hook" mode)))
            prose-modes))
#+end_src


I want to make sure that I've enabled spell-checking if I'm editing text,
composing an email, or authoring a Git commit.

#+begin_src emacs-lisp
  (use-package! flyspell
    :config
    (dolist (hook prose-mode-hooks)
      (add-hook hook 'flyspell-mode)))
#+end_src


=AutoFillMode= automatically wraps paragraphs, kinda like hitting =M-q=. I wrap
a lot of paragraphs, so this automatically wraps 'em when I'm writing text,
Markdown, or Org.

#+begin_src emacs-lisp
  (dolist (hook prose-mode-hooks)
    (add-hook hook 'turn-on-auto-fill))
#+end_src


Enable Org-style tables.

#+begin_src emacs-lisp
  (add-hook 'git-commit-mode-hook 'orgtbl-mode)
  (add-hook 'markdown-mode-hook 'orgtbl-mode)
  (add-hook 'message-mode-hook 'orgtbl-mode)
#+end_src

Use the [[https://elpa.gnu.org/packages/orgalist.html][=orgalist=]] package for more convenient list manipulation.

#+begin_src emacs-lisp
  (use-package! orgalist
    :config
    (add-hook 'git-commit-mode-hook 'orgalist-mode)
    (add-hook 'markdown-mode-hook 'orgalist-mode)
    (add-hook 'message-mode-hook 'orgalist-mode))
#+end_src


I use [[http://proselint.com/][proselint]] to check my prose for common errors. This creates a flycheck
checker that runs proselint in texty buffers and displays my errors.

#+begin_src emacs-lisp
  (require 'flycheck)

  (flycheck-def-executable-var proselint "proselint")
  (flycheck-define-command-checker 'proselint
    "A linter for prose."
    :command '("proselint" source-inplace)
    :error-patterns
    '((warning line-start (file-name) ":" line ":" column ": "
               (id (one-or-more (not (any " "))))
               (message (one-or-more not-newline)
                        (zero-or-more "\n" (any " ") (one-or-more not-newline)))
               line-end))
    :modes prose-modes
    :next-checkers 'nil
    :standard-input 'nil
    :working-directory 'nil)

  (add-to-list 'flycheck-checkers 'proselint)
#+end_src

Use flycheck in the appropriate buffers, which is all prose buffers except
=thebigone.org= because that is big and flycheck is slow and unnecessary there.

#+begin_src emacs-lisp
  (dolist (hook prose-mode-hooks)
    (add-hook hook 'flycheck-mode))

  (defvar no-flycheck-list (list 'org-index-file))

  (defun blw/turn-off-flycheck-if-match ()
    (if (member (file-name-nondirectory (buffer-file-name)) no-flycheck-list)
        (flycheck-mode -1)))

  (add-hook 'find-file-hook #'blw/turn-off-flycheck-if-match)
#+end_src


I look up definitions by hitting =C-x w=, which shells out to =sdcv=. I've
loaded that with the (beautifully lyrical) 1913 edition of Webster's dictionary,
so these definitions are a lot of fun. Dictionaries can be downloaded from [[https://sites.google.com/site/gtonguedict/home/stardict-dictionaries][here]].
By following [[https://linuxaria.com/article/sdcv-command-line-based-dictionary-for-linux][these instructions]].

#+begin_src emacs-lisp
  (defun hrs/dictionary-prompt ()
    (read-string
     (format "Word (%s): " (or (hrs/region-or-word) ""))
     nil
     nil
     (hrs/region-or-word)))

  (defun hrs/dictionary-define-word ()
    (interactive)
    (let* ((word (hrs/dictionary-prompt))
           (buffer-name (concat "Definition: " word)))
      (with-output-to-temp-buffer buffer-name
        (shell-command (format "sdcv -n %s" word) buffer-name))))

  (define-key global-map (kbd "C-c w") 'hrs/dictionary-define-word)
#+end_src


Hitting =C-x s= searches for synonyms for the word at point.

#+begin_src emacs-lisp
  (use-package! powerthesaurus
    :bind
    ("C-c s" . powerthesaurus-lookup-word-dwim))
#+end_src


# Because I can't always use =org=.

# - Associate =.md= files with GitHub-flavored Markdown.
# - Use =pandoc= to render the results.
# - Leave the code block font unchanged.

# #+begin_src emacs-lisp
#   (use-package markdown-mode
#     :commands gfm-mode

#     :mode (("\\.md$" . gfm-mode))

#     :config
#     (setq markdown-command "pandoc --standalone --mathjax --from=markdown")
#     (custom-set-faces
#      '(markdown-code-face ((t nil)))))
# #+end_src


Successive calls to =cycle-spacing= rotate between changing the whitespace
around point to:

- A single space,
- No spaces, or
- The original spacing.

Binding this to =M-SPC= is strictly better than the original binding of
=just-one-space=.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-SPC") 'cycle-spacing)
#+end_src


#+begin_src emacs-lisp
  (put 'downcase-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
#+end_src


Use abbreviations from my emacs directory, and save new abbreviations every time
a file is saved. [[http://ergoemacs.org/emacs/emacs_abbrev_mode_tutorial.html][Documentation here]].

#+begin_src emacs-lisp
  (setq abbrev-file-name "~/.emacs.d/abbrev_defs")
  (setq save-abbrevs 'silent)

  (dolist (hook prose-mode-hooks)
      (add-hook hook 'abbrev-mode))
#+end_src

#+RESULTS:


Remove text without permanently deleting it. Options to send it to the bottom of
the file or a trash file.

#+begin_src emacs-lisp
  (use-package! palimpsest
    :config
    (dolist (hook prose-mode-hooks)
      (add-hook hook 'palimpsest-mode))
    (setq palimpsest-prefix "- ")
    ;; I never send palimpsests to the top, and this command shadows the =org=
    ;; scheduling command I do use.

    (define-key palimpsest-keymap (kbd "C-c C-s") nil))
#+end_src


Hide dotfiles by default, but toggle their visibility with =.=.

#+begin_src emacs-lisp
  (use-package! dired-hide-dotfiles
    :config
    (dired-hide-dotfiles-mode)
    (define-key dired-mode-map "." 'dired-hide-dotfiles-mode))
#+end_src

Open media with the appropriate programs.

#+begin_src emacs-lisp
  (use-package! dired-open
    :config
    (setq dired-open-extensions
          '(("avi" . "open")
            ("cbr" . "open")
            ("doc" . "open")
            ("docx" . "pen")
            ("gif" . "open")
            ("gnumeric" . "open")
            ("html" . "open")
            ("jpeg" . "open")
            ("jpg" . "open")
            ("mkv" . "open")
            ("mov" . "open")
            ("mp3" . "open")
            ("mp4" . "open")
            ("pdf" . "open")
            ("png" . "open")
            ("webm" . "open")
            ("xls" . "open")
            ("xlsx" . "open"))))
#+end_src

These are the switches that get passed to =ls= when =dired= gets a list of
files. We're using:

- =l=: Use the long listing format.
- =h=: Use human-readable sizes.
- =v=: Sort numbers naturally.
- =A=: Almost all. Doesn't include "=.=" or "=..=".

That said, I'd usually like to hide those extra details.
=dired-hide-details-mode= can be toggled with =(=.

#+begin_src emacs-lisp
  (setq-default dired-listing-switches "-lhvA")
  (add-hook 'dired-mode-hook (lambda () (dired-hide-details-mode 1)))
#+end_src

Set up DWIM ("do what I mean") for =dired=. When I've got two =dired= windows
side-by-side, and I move or copy files in one window, this sets the default
location to the other window.

#+begin_src emacs-lisp
  (setq dired-dwim-target t)
#+end_src

Kill buffers of files/directories that are deleted in =dired=.

#+begin_src emacs-lisp
  (setq dired-clean-up-buffers-too t)
#+end_src

Always copy directories recursively instead of asking every time.

#+begin_src emacs-lisp
  (setq dired-recursive-copies 'always)
#+end_src

Ask before recursively /deleting/ a directory, though.

#+begin_src emacs-lisp
  (setq dired-recursive-deletes 'top)
#+end_src

Files are normally moved and copied synchronously. This is fine for small or
local files, but copying a large file or moving a file across a mounted network
drive blocks Emacs until the process is completed. Unacceptable!

This uses =emacs-async= to make =dired= perform actions asynchronously.

#+begin_src emacs-lisp
  (use-package! async
    :config
    (dired-async-mode 1))
#+end_src

I'm often browsing directories of photos and images, so this binds "v" to view a
slideshow of the current directory with =s= (a custom =feh= wrapper defined
elsewhere in this repo).

#+begin_src emacs-lisp
  (defun hrs/dired-slideshow ()
    (interactive)
    (start-process "dired-slideshow" nil "s" (dired-current-directory)))
#+end_src



I futz around with my dotfiles a lot. This binds =C-c e= to quickly open my
Emacs configuration file.

#+begin_src emacs-lisp
  (defun hrs/visit-emacs-config ()
    (interactive)
    (find-file "~/.doom.d/config.org"))

  (global-set-key (kbd "C-c e") 'hrs/visit-emacs-config)
#+end_src


Assume that I always want to kill the current buffer when hitting =C-x k=.

#+begin_src emacs-lisp
  (defun hrs/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (global-set-key (kbd "C-x k") 'hrs/kill-current-buffer)
#+end_src


The =helpful= package provides, among other things, more context in Help
buffers.

#+begin_src emacs-lisp
  (use-package helpful)

  (global-set-key (kbd "C-h f") #'helpful-callable)
  (global-set-key (kbd "C-h v") #'helpful-variable)
  (global-set-key (kbd "C-h k") #'helpful-key)
#+end_src


#+begin_src emacs-lisp
  (hrs/append-to-path "/usr/local/bin")
#+end_src


Using =save-place-mode= saves the location of point for every file I visit. If I
close the file or close the editor, then later re-open it, point will be at the
last place I visited.

#+begin_src emacs-lisp
  (save-place-mode t)
#+end_src


Never use tabs. Tabs are the devil’s whitespace.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

Do this /only/ for lines that I edit.

#+begin_src emacs-lisp
  (use-package! ws-butler
    :config
    (ws-butler-global-mode t))
#+end_src


=which-key= displays the possible completions for a long keybinding. That's
really helpful for some modes (like =projectile=, for example).

#+begin_src emacs-lisp
  (use-package which-key
    :config (which-key-mode))
#+end_src


#+begin_src emacs-lisp
  (use-package yasnippet)
#+end_src

I keep my snippets in =~/.emacs/snippets/text-mode=, and I always want =yasnippet=
enabled.

#+begin_src emacs-lisp
  (setq yas-snippet-dirs '("~/.emacs.d/snippets/text-mode"))
  (yas-global-mode 1)
#+end_src

I /don’t/ want =yas= to automatically indent the snippets it inserts. Sometimes
this looks pretty bad (when indenting org-mode, for example, or trying to guess
at the correct indentation for Python).

#+begin_src emacs-lisp
  (setq yas-indent-line 'auto)
#+end_src


I use =ivy= and =counsel= as my completion framework.

This configuration:

- Uses =counsel-M-x= for command completion,
- Replaces =isearch= with =swiper=,
- Uses =smex= to maintain history,
- Enables fuzzy matching everywhere except swiper (where it's thoroughly
  unhelpful), and
- Includes recent files in the switch buffer.

#+begin_src emacs-lisp
  (use-package! counsel
    :bind
    ("M-x" . 'counsel-M-x)
    ("C-s" . 'swiper)

    :config
    (use-package! flx)
    (use-package! smex)

    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-count-format "(%d/%d) ")
    (setq ivy-initial-inputs-alist nil)
    (setq ivy-re-builders-alist
          '((swiper . ivy--regex-plus)
            (t . ivy--regex-fuzzy))))
#+end_src


When splitting a window, I invariably want to switch to the new window. This
makes that automatic.

#+begin_src emacs-lisp
  (defun hrs/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun hrs/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (global-set-key (kbd "C-x 2") 'hrs/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'hrs/split-window-right-and-switch)
#+end_src

#+begin_src emacs-lisp
  (projectile-global-mode)
#+end_src


Enable [[https://github.com/hrs/engine-mode][engine-mode]] and define a few useful engines.

#+begin_src emacs-lisp
    (use-package! engine-mode)
    (require 'engine-mode)

    (defengine duckduckgo
      "https://duckduckgo.com/?q=%s"
      :keybinding "d")

    (defengine github
      "https://github.com/search?ref=simplesearch&q=%s"
      :keybinding "g")

    (defengine google-scholar
      "https://scholar.google.com/scholar?hl=en&q=%s"
      :keybinding "s")

    (defengine rfcs
      "http://pretty-rfc.herokuapp.com/search?q=%s")

    (engine-mode t)
#+end_src

Make commenting better with =M-;=

#+begin_src emacs-lisp
  (use-package! comment-dwim-2
    :config
    (global-set-key (kbd "M-;") 'comment-dwim-2))
#+end_src
